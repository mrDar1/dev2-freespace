**important notes:**
     mv command do not change time stamp!! must use "touch"

**Constraint:**
    zipped, tgzed(=gunzip tar), bzipped or compressed == do not zip again.

**Workflow:**
    if edge case:
        if no arguments passed - exit.

    **catch flags** 
        use getopts and OPTIND shift $((OPTIND-1)): 
            -r
            -t - if not added number default is 48 hourst add MACRO.



    **iterate over files:**
        find_type.
        cur_file

        case simple text:
            zip it and change name as instructed.
            then, delete the original file.
        case directory:
            check if -r flag is set if so enter, else exit.
        case cur_file == fc-*:
            check time stamp.
            if time stamp bigger than 48 - delete.
        case cur_file != fc-*:
            case zip:
            case buzip:
            case gzip:
            case compressed:
            rename file: to fc-<filename>
            update time stamp with "touch"
        
        case *:
            counte how many unkown types.
        if any other type:
            count as unkown type.

    







**testing:**
    Update to a specific timestamp:
        $ touch -t YYYYMMDDHHMM filename
        $ touch -t 202505061030 filename example, to set the timestamp to May 6, 2025, at 10:30 AM



**bash syntax**
	$ bash -x myscript
		will print anything!! after interpretation / evaluation of vars (will not print $0 but print "myscript") 
		good for debug.

	$ bash -v myscript
		will print anything!! before interpretation / evaluation of vars (will do print $0 but not print "myscript") 
		less good for debug.

	$ bash -xv myscript
		will print both - best!!! very clear!!



    echo -e
        -e Enables interpretation of escape sequences (like \n, \t, etc.).
        color wont work without it!
    
    zip -qq "${cur_file}.zip" "${cur_file}"
    mv "${cur_file}.zip" "fc-${cur_file}.zip"
    ==== 
    zip -qq "fc-${cur_file}.zip" "${cur_file}"
        both are same!! different syntax

    $*    
        All arguments passed to the script/function, as a single space-separated string.
    $#	
        Number of arguments passed to the script or function (not include name $0).

    freespace_command "$@"
        "$@"   
            Call the function or command and pass along all original arguments, preserving spacing.
            example:
                    ./freespace.sh one "two words" three
                    freespace_command "$@" ==
                    freespace_command "one" "two words" "three"

                    freespace_command $@   ==
                    freespace_command "one" "two" "words" "three"

    for cur_file in "${files_list[@]}"; do
        files_list[@]
             if not use [@]   -  will only print the first of the arr and loop ends!! not the rest!!


    file_type=$(file --mime-type -b "${cur_file}") 
        --mime-type -b
            brief version of mime type
    

    if [ "$is_recursive" = true ]; then
        ==
        is equal to:
    if [[ "$is_recursive" == true ]]; then
        the first is posix supported
        the second is bash syntax


    pushd "$cur_file" > /dev/null 2>&1
        ====
    pushd "$cur_file" > /dev/null 2>/dev/null
        # both the same!!

        > /dev/null	
            hides normal output.
            special file in Unix/Linux systems that discards anything written to it
            ("The Linux toilet", "The digital black hole")    
        2>&1	
            Redirects standard error (stderr) to the same place as stdout ‚Äî also to /dev/null.


    
    if [[ ! "$OPTARG" =~ ^[0-9]+$ ]]; then
        if [[ ... ]]	
            Bash conditional expression  (more powerful than [ ... ]). for regex must come with =~
        =~	
            Bash operator for regex matching.
        ^[0-9]+$	
            Regex pattern meaning: "string of one or more digits only".
            | Part    | Meaning                                               |
            | ------- | ----------------------------------------------------- |
            | `^`     | Start of the string (anchoring)                       |
            | `[0-9]` | A single digit (0 through 9)                          |
            | `+`     | One or more of the previous character class (`[0-9]`) |
            | `$`     | End of the string (anchoring)                         |




**extra notes**

GLOBs == global regex


 /dev/zero
    Always outputs zeros (0x00, null bytes).
    üîß Use case: initialize empty files or wipe disks:

üîç /dev/random
    Outputs true random data, gathered from environmental noise (keyboard, mouse, disk, etc).
    Can block if there's not enough entropy.
    üîß Use case: secure key generation.
    ```bash
    head -c 16 /dev/random > secret.key
    ```

üîç /dev/urandom
    Outputs pseudorandom data (generated by a CSPRNG seeded from /dev/random).
    Does not block, but slightly less secure.
    üîß Use case: safe default for non-cryptographic randomness or non-blocking key gen: